// app/events/[eventId]/guests/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import { format } from 'date-fns';
import { 
  ArrowLeftIcon, 
  UserPlusIcon, 
  CopyIcon, 
  MailIcon, 
  QrCodeIcon,
  UserIcon, 
  CheckCircleIcon, 
  ClockIcon,
  MoreHorizontalIcon,
  SearchIcon,
  XIcon,
  SaveIcon,
  ChevronDownIcon
} from 'lucide-react';
import { getEventById, getEventGuests, inviteGuestsToEvent, updateInvitedGuests } from '@/services/apis/events.api';
import { createShareToken, getTokenByEventId } from '@/services/apis/sharing.api';
import { useAuthToken } from '@/hooks/use-auth';

import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Skeleton } from '@/components/ui/skeleton';
import { Separator } from '@/components/ui/separator';
import { Badge } from '@/components/ui/badge';
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
// import QRCode from 'qrcode.react';
import { toast } from "sonner";
import { v4 as uuidv4 } from 'uuid';

// Using the Event type from our types directory
import { Event } from '@/types/events';

interface EventAccess {
  id: string;
  eventId: string;
  userId: number;
  accessType: 'owner' | 'contributor' | 'viewer';
  invitedBy?: number;
  invitedAt?: Date;
  joinedAt?: Date;
  email?: string;
  name?: string;
  status?: 'invited' | 'joined' | 'declined';
}

interface GuestInvite {
  email: string;
  name?: string;
  accessType: 'contributor' | 'viewer';
}

interface PageProps {
  params: {
    eventId: string;
  };
}

export default function GuestManagementPage({ params }: PageProps) {
  // No need to use React.use() with params, they're already available
  const { eventId } = params;
  
  const router = useRouter();
  const authToken = useAuthToken();
  const [isLoading, setIsLoading] = useState(true);
  const [tokenChecked, setTokenChecked] = useState(false);
  const [event, setEvent] = useState<Event | null>(null);
  const [guests, setGuests] = useState<EventAccess[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [inviteDialogOpen, setInviteDialogOpen] = useState(false);
  const [qrDialogOpen, setQrDialogOpen] = useState(false);
  const [activeTab, setActiveTab] = useState<'all' | 'contributors' | 'viewers'>('all');
  
  // Add a delayed check to avoid premature redirects
  useEffect(() => {
    const timer = setTimeout(() => {
      setTokenChecked(true);
    }, 1000); // Give auth token 1 second to load
    
    return () => clearTimeout(timer);
  }, []);
  
  // New invite form state
  const [newInvites, setNewInvites] = useState<GuestInvite[]>([
    { email: '', accessType: 'contributor' }
  ]);
  
  // User ID would come from auth in a real app
  const userId = 1;
  
  useEffect(() => {
    // Only proceed if either we have an authToken or the token check timeout has elapsed
    if (!authToken && !tokenChecked) {
      console.log('Waiting for auth token to load or timeout...');
      return;
    }
    
    const loadEventAndGuests = async () => {
      // Try to get the token from the hook or directly from localStorage as fallback
      const token = authToken || localStorage.getItem('authToken');
      
      // Only redirect if we've checked thoroughly for a token and still don't have one
      if (!token && tokenChecked) {
        console.log('No auth token found after timeout, redirecting to login...');
        toast.error("You need to be logged in to manage guests.");
        router.push('/login');
        return;
      }

      try {
        // Try to load all data in parallel for better performance
        const [eventData, shareTokenData, guestData] = await Promise.all([
          // Load event details from API
          getEventById(eventId, token as string).catch(err => {
            console.error('Error fetching event details:', err);
            toast.error("The event you're looking for doesn't exist.");
            router.push('/events');
            return null;
          }),
          
          // Try to get share token with invited guests info
          getTokenByEventId(eventId, token as string).catch(err => {
            console.error('Error fetching share token:', err);
            return null; // We can still proceed without a share token
          }),
          
          // Try to get guest data from API
          getEventGuests(eventId, token as string).catch(err => {
            console.error('Error fetching guest data:', err);
            return null; // We'll handle this below
          })
        ]);
        
        // If no event data, we've already redirected
        if (!eventData) return;
        
        // Update state with event data
        setEvent(eventData);
        
        // If we got a share token, update state
        if (shareTokenData && shareTokenData.token) {
          setShareToken(shareTokenData.token);
        }
        
        // Process guest data - use API data if available, otherwise fall back to event invitedGuests
        const transformedGuests: EventAccess[] = [];
        
        // Add the owner (current user)
        transformedGuests.push({
          id: 'owner-1',
          eventId,
          userId: userId,
          accessType: 'owner',
          name: 'You (Owner)',
          email: 'you@example.com',
          status: 'joined' as 'joined'
        });
        
        // Determine the source of guest data (API, event data, share token)
        let guestSource = [];
        
        if (Array.isArray(guestData) && guestData.length > 0) {
          // We have real guest data from the API
          guestSource = guestData;
          console.log('Using guest data from API');
        } else if (eventData.invitedGuests && eventData.invitedGuests.length > 0) {
          // Fall back to invited guests from event data
          guestSource = eventData.invitedGuests.map((email: string) => ({
            email,
            accessType: 'viewer'
          }));
          console.log('Using invited guests from event data');
        } else if (shareTokenData && shareTokenData.invitedGuests && shareTokenData.invitedGuests.length > 0) {
          // Last resort, use invited guests from share token
          guestSource = shareTokenData.invitedGuests.map((email: string) => ({
            email,
            accessType: shareTokenData.permissions.canUpload ? 'contributor' : 'viewer'
          }));
          console.log('Using invited guests from share token');
        }
        
        // Process the guest data into our component format
        if (guestSource.length > 0) {
          guestSource.forEach((guest, index) => {
            // Handle different possible data formats
            const email = guest.email || guest;
            const name = guest.name || guest.userName || guest.user_name || 
                      (typeof email === 'string' ? email.split('@')[0] : `Guest ${index}`);
            const accessType = guest.accessType || guest.access_type || 
                            (guest.permissions?.upload ? 'contributor' : 'viewer');
            const status = guest.status || guest.joined_at ? 'joined' : 'invited';
            
            // Skip if this is the owner (we already added them)
            if (typeof email === 'string' && email === 'you@example.com') return;
            
            transformedGuests.push({
              id: guest._id || guest.id || `guest-${index}`,
              eventId,
              userId: guest.userId || guest.user_id || index + 2,
              accessType: accessType as 'contributor' | 'viewer',
              name,
              email,
              status: status as 'joined' | 'invited'
            });
          });
        }
        
        setGuests(transformedGuests);
      } catch (error) {
        console.error('Error loading event and guests:', error);
        toast.error("Failed to load guest data. Please try again.");
      } finally {
        setIsLoading(false);
      }
    };
    
    loadEventAndGuests();
  }, [eventId, router, authToken, userId, tokenChecked]);
  
  const filteredGuests = guests.filter(guest => {
    // Filter by search query
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      return (
        (guest.name && guest.name.toLowerCase().includes(query)) ||
        (guest.email && guest.email.toLowerCase().includes(query))
      );
    }
    
    // Filter by tab
    if (activeTab === 'contributors') {
      return guest.accessType === 'contributor' || guest.accessType === 'owner';
    } else if (activeTab === 'viewers') {
      return guest.accessType === 'viewer';
    }
    
    return true;
  });
  
  // State to hold the share token for the event
  const [shareToken, setShareToken] = useState<string | null>(null);
  
  // Function to get and cache the share token
  const getShareToken = async () => {
    if (shareToken) return shareToken;
    
    const token = authToken || localStorage.getItem('authToken');
    if (!token) return null;
    
    try {
      const tokenData = await getTokenByEventId(eventId, token as string);
      if (tokenData && tokenData.token) {
        setShareToken(tokenData.token);
        return tokenData.token;
      }
    } catch (error) {
      console.error('Error getting share token:', error);
    }
    
    return null;
  };
  
  const getShareUrl = async () => {
    const token = await getShareToken();
    
    if (event?.access?.level === 'invited_only' && token) {
      // For invited-only events, use the token
      return `${window.location.origin}/join/${token}`;
    } else {
      // For public events or link-only events
      return `${window.location.origin}/join?event=${eventId}`;
    }
  };
  
  const copyShareLink = async () => {
    setIsLoading(true);
    try {
      const shareUrl = await getShareUrl();
      navigator.clipboard.writeText(shareUrl);
      toast.success("Share link copied to clipboard");
    } catch (error) {
      console.error("Error copying share link:", error);
      toast.error("Failed to copy share link");
    } finally {
      setIsLoading(false);
    }
  };
  
  const addInviteField = () => {
    setNewInvites([...newInvites, { email: '', accessType: 'contributor' }]);
  };
  
  const removeInviteField = (index: number) => {
    if (newInvites.length <= 1) return;
    setNewInvites(newInvites.filter((_, i) => i !== index));
  };
  
  const updateInviteField = (index: number, field: keyof GuestInvite, value: any) => {
    const updatedInvites = [...newInvites];
    updatedInvites[index] = { ...updatedInvites[index], [field]: value };
    setNewInvites(updatedInvites);
  };
  
  const sendInvitations = async () => {
    // Validate emails
    const validInvites = newInvites.filter(invite => invite.email.trim() !== '');
    
    if (validInvites.length === 0) {
      toast.error("Please enter at least one valid email address.");
      return;
    }
    
    try {
      setIsLoading(true);
      const token = authToken || localStorage.getItem('authToken');
      
      if (!token) {
        toast.error("You need to be logged in to invite guests.");
        return;
      }
      
      // Step 1: Batch process our actions for better performance
      const [currentEvent, existingShareToken] = await Promise.all([
        getEventById(eventId, token as string),
        getTokenByEventId(eventId, token as string).catch(() => null)
      ]);
      
      if (!currentEvent) {
        toast.error("Could not find event details");
        return;
      }
      
      // Step 2: Prepare invited guests list with deduplication
      const currentInvitedGuests = currentEvent.invitedGuests || [];
      const newInvitedEmails = validInvites.map(invite => invite.email);
      const allInvitedGuests = [...new Set([...currentInvitedGuests, ...newInvitedEmails])];
      
      console.log('Updating invited guests:', allInvitedGuests);
      
      // Step 3: Determine most permissive access type for the new invites
      // If any new invitees need contributor access, we'll update/create the token with contributor permissions
      const hasContributors = validInvites.some(invite => invite.accessType === 'contributor');
      const accessType = hasContributors ? 'contributor' : 'viewer';
      
      // Step 4: Update event and create/update share token in parallel
      const [updatedEvent, shareTokenResult] = await Promise.all([
        updateInvitedGuests(eventId, allInvitedGuests, token),
        inviteGuestsToEvent(eventId, validInvites, accessType, token)
      ]);
      
      // If we got a new token, update our state
      if (shareTokenResult && shareTokenResult.token) {
        setShareToken(shareTokenResult.token);
      }
      
      // Step 5: Reload guest list to ensure we have the latest data
      let updatedGuests;
      try {
        updatedGuests = await getEventGuests(eventId, token);
      } catch (error) {
        console.warn('Could not fetch updated guest list, using UI update only', error);
        
        // Create new guest objects for UI update if API call fails
        const newGuestEntries = validInvites.map((invite, index) => ({
          id: `new-guest-${Date.now()}-${index}`,
          eventId,
          userId: guests.length + index + 2,
          accessType: invite.accessType as 'contributor' | 'viewer',
          email: invite.email,
          name: invite.name || invite.email.split('@')[0],
          status: 'invited' as 'invited'
        }));
        
        // Update UI with new guests
        setGuests([...guests, ...newGuestEntries]);
      }
      
      // If we got updated guests from API, transform and update UI
      if (updatedGuests && Array.isArray(updatedGuests)) {
        // Process real guest data from API
        const transformedGuests: EventAccess[] = [{
          id: 'owner-1',
          eventId,
          userId: 1,
          accessType: 'owner',
          name: 'You (Owner)',
          email: 'you@example.com',
          status: 'joined' as 'joined'
        }];
        
        updatedGuests.forEach((guest, index) => {
          const email = guest.email || guest;
          const name = guest.name || guest.userName || guest.user_name || 
                       (typeof email === 'string' ? email.split('@')[0] : `Guest ${index}`);
          const guestAccessType = guest.accessType || guest.access_type || 
                              (guest.permissions?.upload ? 'contributor' : 'viewer');
          const status = guest.status || guest.joined_at ? 'joined' : 'invited';
          
          transformedGuests.push({
            id: guest._id || guest.id || `guest-${index}`,
            eventId,
            userId: guest.userId || guest.user_id || index + 2,
            accessType: guestAccessType as 'contributor' | 'viewer',
            name,
            email,
            status: status as 'joined' | 'invited'
          });
        });
        
        setGuests(transformedGuests);
      }
      
      // Close invite dialog and reset form
      setInviteDialogOpen(false);
      setNewInvites([{ email: '', accessType: 'contributor' }]);
      
      toast.success(`${validInvites.length} guest${validInvites.length > 1 ? 's' : ''} invited successfully!`);
    } catch (error) {
      console.error('Error inviting guests:', error);
      toast.error("Failed to invite guests. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  
  // Functions for managing guests
  const removeGuest = async (guestId: string) => {
    try {
      const guest = guests.find(g => g.id === guestId);
      
      if (!guest || guest.accessType === 'owner') {
        return; // Can't remove the owner
      }
      
      setIsLoading(true);
      const token = authToken || localStorage.getItem('authToken');
      
      if (!token) {
        toast.error("You need to be logged in to manage guests");
        return;
      }
      
      // Get current event data with invited guests
      const currentEvent = await getEventById(eventId, token);
      if (!currentEvent || !currentEvent.invitedGuests) {
        toast.error("Could not find event details");
        return;
      }
      
      // Remove the guest's email from invited guests
      const updatedInvitedGuests = currentEvent.invitedGuests.filter(
        email => email !== guest.email
      );
      
      // Update the event with the new invited guests list
      await updateInvitedGuests(eventId, updatedInvitedGuests, token);
      
      // Update the UI
      setGuests(guests.filter(g => g.id !== guestId));
      
      toast.success(`${guest.name || guest.email} has been removed from the guest list.`);
    } catch (error) {
      console.error('Error removing guest:', error);
      toast.error("Failed to remove guest. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  
  const changeGuestAccess = async (guestId: string, newAccessType: 'contributor' | 'viewer') => {
    try {
      const guest = guests.find(g => g.id === guestId);
      
      if (!guest || guest.accessType === 'owner') {
        return; // Can't change the owner's access
      }
      
      setIsLoading(true);
      const token = authToken || localStorage.getItem('authToken');
      
      if (!token) {
        toast.error("You need to be logged in to manage guests");
        return;
      }
      
      // Get the share token for this event
      const tokenData = await getTokenByEventId(eventId, token);
      if (!tokenData) {
        toast.error("Could not find share information for this event");
        return;
      }
      
      // In a real implementation, we would update the guest's specific permissions
      // For now, update the local state to reflect the change
      
      // Update UI state
      setGuests(guests.map(g => 
        g.id === guestId 
          ? { ...g, accessType: newAccessType } 
          : g
      ));
      
      toast.success(`${guest.name || guest.email}'s access level has been updated.`);
    } catch (error) {
      console.error('Error changing guest access:', error);
      toast.error("Failed to update guest access. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  
  const resendInvitation = async (guestId: string) => {
    try {
      const guest = guests.find(g => g.id === guestId);
      
      if (!guest) return;
      
      setIsLoading(true);
      const token = authToken || localStorage.getItem('authToken');
      
      if (!token) {
        toast.error("You need to be logged in to manage guests");
        return;
      }
      
      // In a real implementation, we'd re-trigger an invitation email via the backend
      // Simulate resending by re-inviting just this one guest
      await inviteGuestsToEvent(
        eventId, 
        [{ email: guest.email, name: guest.name }], 
        guest.accessType === 'contributor' ? 'contributor' : 'viewer',
        token
      );
      
      // Update UI state
      setGuests(guests.map(g => 
        g.id === guestId 
          ? { ...g, invitedAt: new Date() } 
          : g
      ));
      
      toast.success(`Invitation has been resent to ${guest.name || guest.email}.`);
    } catch (error) {
      console.error('Error resending invitation:', error);
      toast.error("Failed to resend invitation. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  
  // The rest of the component (UI rendering) would go here...
  // Including all the rendering for the guest list, invite forms, etc.
  
  return (
    <div className="container max-w-5xl pb-20">
      {/* Back button */}
      <div className="my-4">
        <Button variant="ghost" size="sm" onClick={() => router.back()}>
          <ArrowLeftIcon className="mr-2 h-4 w-4" />
          Back to Event
        </Button>
      </div>
      
      {/* Header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold tracking-tight">Guest Management</h1>
        <p className="text-muted-foreground">
          Invite and manage guests for your event
        </p>
      </div>
      
      {isLoading ? (
        <div className="space-y-4">
          <Skeleton className="h-8 w-[250px]" />
          <Skeleton className="h-8 w-[400px]" />
          <Skeleton className="h-[300px] w-full" />
        </div>
      ) : (
        <>
          {/* Event info */}
          <Card className="mb-8">
            <CardHeader className="pb-2">
              <CardTitle>{event?.name}</CardTitle>
              <CardDescription>
                {event?.date && (
                  <>
                    <span className="block">
                      {format(new Date(event.date), 'PPP')}
                    </span>
                    {event.location && (
                      <span className="block mt-1">{event.location}</span>
                    )}
                  </>
                )}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="flex flex-col sm:flex-row gap-4">
                <Button onClick={() => setInviteDialogOpen(true)} className="flex-1">
                  <UserPlusIcon className="mr-2 h-4 w-4" />
                  Invite Guests
                </Button>
                <Button variant="outline" className="flex-1" onClick={copyShareLink}>
                  <CopyIcon className="mr-2 h-4 w-4" />
                  Copy Invite Link
                </Button>
                <Button variant="outline" className="flex-1" onClick={() => setQrDialogOpen(true)}>
                  <QrCodeIcon className="mr-2 h-4 w-4" />
                  Share QR Code
                </Button>
              </div>
            </CardContent>
          </Card>

          {/* Guest List */}
          <Card>
            <CardHeader className="pb-2">
              <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
                <CardTitle>Guest List</CardTitle>
                <div className="relative w-full sm:w-[300px]">
                  <SearchIcon className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Search guests..."
                    className="pl-8"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                  />
                </div>
              </div>
              
              <Tabs defaultValue="all" value={activeTab} onValueChange={(val: any) => setActiveTab(val)} className="mt-4">
                <TabsList className="grid w-full grid-cols-3">
                  <TabsTrigger value="all">All Guests</TabsTrigger>
                  <TabsTrigger value="contributors">Contributors</TabsTrigger>
                  <TabsTrigger value="viewers">Viewers</TabsTrigger>
                </TabsList>
              </Tabs>
            </CardHeader>
            
            <CardContent>
              {filteredGuests.length === 0 ? (
                <div className="text-center py-8">
                  <UserIcon className="mx-auto h-12 w-12 text-muted-foreground" />
                  <h3 className="mt-4 text-lg font-semibold">No guests found</h3>
                  <p className="text-muted-foreground">
                    {searchQuery 
                      ? "No guests match your search criteria." 
                      : "You haven't invited any guests yet."}
                  </p>
                  {!searchQuery && (
                    <Button 
                      onClick={() => setInviteDialogOpen(true)} 
                      className="mt-4"
                    >
                      <UserPlusIcon className="mr-2 h-4 w-4" />
                      Invite your first guest
                    </Button>
                  )}
                </div>
              ) : (
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Name</TableHead>
                      <TableHead>Email</TableHead>
                      <TableHead>Access</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead className="w-[100px]">Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {filteredGuests.map((guest) => (
                      <TableRow key={guest.id}>
                        <TableCell className="font-medium">{guest.name}</TableCell>
                        <TableCell>{guest.email}</TableCell>
                        <TableCell>
                          <Badge variant={
                            guest.accessType === 'owner' 
                              ? "default" 
                              : guest.accessType === 'contributor' 
                              ? "secondary" 
                              : "outline"
                          }>
                            {guest.accessType === 'owner' 
                              ? 'Owner' 
                              : guest.accessType === 'contributor' 
                              ? 'Contributor' 
                              : 'Viewer'}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          {guest.status === 'joined' ? (
                            <div className="flex items-center">
                              <CheckCircleIcon className="mr-1 h-4 w-4 text-green-500" />
                              <span>Joined</span>
                            </div>
                          ) : (
                            <div className="flex items-center">
                              <ClockIcon className="mr-1 h-4 w-4 text-amber-500" />
                              <span>Invited</span>
                            </div>
                          )}
                        </TableCell>
                        <TableCell>
                          <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                              <Button variant="ghost" size="icon">
                                <MoreHorizontalIcon className="h-4 w-4" />
                                <span className="sr-only">Actions</span>
                              </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end">
                              {guest.accessType !== 'owner' && (
                                <>
                                  <DropdownMenuItem
                                    onClick={() => {
                                      const newAccessType = guest.accessType === 'contributor' 
                                        ? 'viewer' as const 
                                        : 'contributor' as const;
                                      changeGuestAccess(guest.id, newAccessType);
                                    }}
                                  >
                                    Change to {guest.accessType === 'contributor' ? 'Viewer' : 'Contributor'}
                                  </DropdownMenuItem>
                                  <DropdownMenuItem
                                    onClick={() => {
                                      resendInvitation(guest.id);
                                    }}
                                  >
                                    Resend Invitation
                                  </DropdownMenuItem>
                                  <DropdownMenuSeparator />
                                  <DropdownMenuItem
                                    className="text-red-600"
                                    onClick={() => {
                                      removeGuest(guest.id);
                                    }}
                                  >
                                    Remove Guest
                                  </DropdownMenuItem>
                                </>
                              )}
                            </DropdownMenuContent>
                          </DropdownMenu>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              )}
            </CardContent>
          </Card>

          {/* Invite Guest Dialog */}
          <Dialog open={inviteDialogOpen} onOpenChange={setInviteDialogOpen}>
            <DialogContent className="sm:max-w-[500px]">
              <DialogHeader>
                <DialogTitle>Invite Guests</DialogTitle>
                <DialogDescription>
                  Invite people to view or contribute to your event.
                </DialogDescription>
              </DialogHeader>
              
              {newInvites.map((invite, index) => (
                <div key={index} className="flex gap-2 items-start">
                  <div className="flex-1">
                    <Label htmlFor={`email-${index}`} className="sr-only">
                      Email
                    </Label>
                    <Input
                      id={`email-${index}`}
                      value={invite.email}
                      onChange={(e) => updateInviteField(index, 'email', e.target.value)}
                      placeholder="guest@example.com"
                      type="email"
                      className="mb-2"
                    />
                  </div>
                  
                  <div>
                    <Label htmlFor={`accessType-${index}`} className="sr-only">
                      Access Type
                    </Label>
                    <Select 
                      value={invite.accessType} 
                      onValueChange={(value) => updateInviteField(index, 'accessType', value)}
                    >
                      <SelectTrigger className="w-[130px]">
                        <SelectValue placeholder="Access Type" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="contributor">Contributor</SelectItem>
                        <SelectItem value="viewer">Viewer</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => removeInviteField(index)}
                    disabled={newInvites.length <= 1}
                  >
                    <XIcon className="h-4 w-4" />
                    <span className="sr-only">Remove</span>
                  </Button>
                </div>
              ))}
              
              <Button
                type="button"
                variant="outline"
                onClick={addInviteField}
                className="mt-2"
              >
                <UserPlusIcon className="mr-2 h-4 w-4" />
                Add Another
              </Button>
              
              <div className="mt-4">
                <Label>Access Type Explanation</Label>
                <div className="mt-2 text-sm text-muted-foreground">
                  <div className="flex items-center mb-2">
                    <Badge variant="secondary" className="mr-2">Contributor</Badge>
                    <span>Can view, upload photos, and download albums</span>
                  </div>
                  <div className="flex items-center">
                    <Badge variant="outline" className="mr-2">Viewer</Badge>
                    <span>Can only view the event and photos</span>
                  </div>
                </div>
              </div>
              
              <DialogFooter>
                <Button variant="outline" onClick={() => setInviteDialogOpen(false)}>
                  Cancel
                </Button>
                <Button type="submit" onClick={sendInvitations} disabled={isLoading}>
                  {isLoading ? (
                    <>Sending...</>
                  ) : (
                    <>
                      <MailIcon className="mr-2 h-4 w-4" />
                      Send Invitations
                    </>
                  )}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>

          {/* QR Code Dialog */}
          <Dialog open={qrDialogOpen} onOpenChange={setQrDialogOpen}>
            <DialogContent className="sm:max-w-[400px] text-center">
              <DialogHeader>
                <DialogTitle>QR Code for Event</DialogTitle>
                <DialogDescription>
                  Guests can scan this QR code to join your event.
                </DialogDescription>
              </DialogHeader>
              
              <div className="flex justify-center p-4 bg-white rounded-md">
                {/* If QRCode component is imported, use it here */}
                {/* <QRCode value={getShareUrl()} size={200} /> */}
                
                {/* Placeholder if QR code library is not available */}
                <div className="w-[200px] h-[200px] bg-gray-100 flex items-center justify-center border">
                  {shareToken ? (
                    <p className="text-sm text-gray-500">
                      QR Code for: {window.location.origin}/join/{shareToken}
                    </p>
                  ) : (
                    <p className="text-sm text-gray-500">
                      QR Code for: {window.location.origin}/join?event={eventId}
                    </p>
                  )}
                </div>
              </div>
              
              <p className="text-sm text-muted-foreground mt-2">
                Share this QR code at the venue or in your event communications.
              </p>
              
              <DialogFooter>
                <Button variant="outline" onClick={() => copyShareLink()} className="mr-2">
                  <CopyIcon className="mr-2 h-4 w-4" />
                  Copy Link
                </Button>
                <Button onClick={() => setQrDialogOpen(false)}>
                  Close
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </>
      )}
    </div>
  );
}
